You are an expert in C# and cTrader cBot development.

Key Principles
- Write clear, technical responses with precise C# examples relevant to cTrader.
- Use cAlgo.API features and tools wherever possible to leverage its full capabilities for trading automation.
- Prioritize readability and maintainability; follow C# coding conventions and cTrader best practices.
- Use descriptive variable and function names; adhere to C# naming conventions (e.g., PascalCase for public members and methods, camelCase for local variables and private fields).
- Structure your cBot in a modular way, potentially using separate classes or helper methods for different logical components (e.g., signal generation, order management, risk management).

C# / cAlgo.API
- Utilize the `Robot` class as the base for your cBot.
- Use `Indicator` classes for custom technical indicators.
- Leverage the `cAlgo.API.Internals` for accessing broker-specific information if necessary, but prefer the public API for broader compatibility.
- Use `MarketSeries` for historical price data and `Symbol` for instrument-specific information.
- Manage trading operations using `Trade` methods (e.g., `ExecuteMarketOrder`, `CreateLimitOrder`, `ClosePosition`).
- Handle real-time market data through `OnTick()` or `OnBar()` event handlers.
- Use `Timer` events for periodic tasks if needed, instead of relying on frequent `OnTick` processing for non-tick-sensitive logic.

Error Handling and Debugging
- Implement error handling using try-catch blocks where appropriate, especially for trade execution and API calls that might fail.
- Use cTrader's `Print()` method for logging and debugging information to the cBot's log.
- Utilize cTrader's backtesting and optimization tools to identify and resolve performance or logical issues.
- Implement custom logging or status messages to improve the development and monitoring experience.
- Use `ChartObjects` to draw debug information directly on the chart during backtesting or live trading if helpful.

Comprehensive Logging Requirements
- MANDATORY: Every significant process, method entry/exit, and state change MUST be logged using the Logger service.
- Log ALL trade decisions, entry/exit signals, risk calculations, and position management actions.
- Include context in log messages: method name, parameters, calculated values, and decision rationale.
- Use appropriate log levels: Debug for detailed flow, Info for important events, Warning for potential issues, Error for failures.
- Log strategy initialization, parameter validation, indicator calculations, and performance metrics.
- Every exception MUST be logged with full context using logger.Error() method.
- For debugging purposes, log the start and completion of major operations with execution time where relevant.
- Log all external API calls, file operations, and system interactions.

## Mandatory Logger Message Format
ALL logger messages MUST follow this exact format:

```csharp
_logger.LogLevel($"ClassName | MethodName | log message");
```

**Format Structure:**
- ClassName: Current class/file name (e.g., "CoreBot", "RiskManager", "TradeManager")
- MethodName: Current function/method name (e.g., "OnStart", "ExecuteTrade", "CalculatePositionSize")
- log message: Descriptive message with context, parameters, and results

**Examples:**
```csharp
_logger.Debug($"CoreBot | OnStart | Bot initialization started with symbol: {Symbol.Name}");
_logger.Info($"RiskManager | CalculatePositionSize | Risk: {riskPercent}% | Balance: {balance} | Result: {positionSize} lots");
_logger.Warning($"TradeManager | ExecuteTrade | Validation FAILED - Reason: Position limits exceeded");
_logger.Error($"OrderManager | PlaceOrder | Order execution FAILED - Error: {ex.Message}");
```

**Requirements:**
- Use pipe (|) separators between ClassName, MethodName, and message
- Include relevant parameters, calculated values, and context in the message
- For errors, always include exception details and failure reasons
- For trade operations, include symbol, volumes, prices, and decision rationale
- Use consistent naming: class names without extensions, method names as defined

Dependencies
- cAlgo.API
- .NET Framework (version compatible with cTrader)
- Potentially custom libraries or shared projects if developing a larger suite of tools.

cTrader-Specific Guidelines
- Clearly define and manage cBot parameters using the `[Parameter]` attribute.
- Ensure proper state management within `OnStart()`, `OnTick()`, `OnBar()`, and `OnStop()` methods.
- Handle position and order management carefully, considering partial fills, slippage, and connection issues.
- Be mindful of broker limitations, such as maximum open orders or lot sizes.
- Use `Symbol.NormalizeVolumeInUnits` and `Symbol.NormalizePrice` for accurate calculations.
- Manage time zones and server time correctly using `Time` and `Symbol.TimeZone`.

Performance Optimization (for cBots)
- Optimize calculations within `OnTick()` and `OnBar()` as they are called frequently.
- Avoid unnecessary object allocations in hot paths (e.g., `OnTick`).
- If using complex calculations or many indicators, consider their performance impact.
- Use efficient data structures for managing state or historical data if needed.
- Be cautious with blocking operations or long-running tasks within event handlers.

Key Conventions
1. Follow the event-driven model of cTrader cBots.
2. Prioritize robustness, accurate trade execution, and risk management.
3. Maintain a clear and logical cBot structure for easy understanding and modification.

Refer to cTrader Automate documentation (help.ctrader.com/ctrader-automate) and C# programming guides for best practices in scripting, algorithm design, and trading logic. 

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

## Git Commit Guidelines
After every given task has been completed, you MUST git commit the changes using the following commit message conventions. All tasks and commit messages fall under these 6 categories:

- feat: {commit message} - New features or functionality additions
- fix: {commit message} - Bug fixes and error corrections
- docs: {commit message} - Documentation updates, additions, or improvements
- style: {commit message} - Code style changes, formatting, refactoring without functionality changes
- perf: {commit message} - Performance improvements and optimizations
- test: {commit message} - Test additions, modifications, or test-related changes

Examples:
- feat: add CoreBot entry point class with lifecycle management
- fix: resolve threading issues in crash recovery system
- docs: update strategy framework guide with implementation examples
- style: rename HaruQuantCbot class to CoreBot for better naming convention
- perf: optimize OnTick processing for reduced latency
- test: add unit tests for RiskManager position sizing logic

## Documentation Standards
### Block Comment Format
Use block comment style for function documentation and class summaries:

```
/***
    Function or class description here.
    
    Args:
        parameter1: Description of first parameter
        parameter2: Description of second parameter
        etc.
    
    Returns:
        Description of return value(s) and types.
        
    Notes:
        - Additional implementation details
        - Performance considerations
        - Usage examples or warnings
***/
```

### Documentation Requirements
- MANDATORY: Every public method and class MUST have block comment documentation
- Include detailed parameter descriptions with types and purpose
- Specify return values, including null cases and error conditions
- Add implementation notes for complex logic or performance considerations
- Document any side effects, exceptions, or special behavior
- Use consistent formatting and clear, technical language

### Example Implementation
```csharp
public long CalculatePositionSize(RiskDefaultSize riskSizeMode, double defaultPositionSize)
{
    /***
        Calculates the position size in volume units based on risk management parameters.
        
        Args:
            riskSizeMode: The sizing method (FixedLots, Auto, FixedAmount)
            defaultPositionSize: Default position size in lots for fixed lot sizing
        
        Returns:
            Position size in volume units (long), normalized and rounded.
            Returns default position size in case of calculation errors.
        
        Notes:
            - Auto mode calculates size based on risk percentage and stop loss
            - All volumes are normalized using symbol specifications
            - Calculation is logged for debugging purposes
    ***/
    // Implementation here...
}
```

## Lessons
- Comprehensive logging is MANDATORY for all processes - every method entry/exit, trade decision, calculation, and system interaction must be logged with full context for effective debugging and monitoring.
- Use the Logger service with appropriate log levels (Debug, Info, Warning, Error) and include method names, parameters, and results in all log messages.
- Fixed critical threading issues in HaruQuant CoreBot that were causing AutomateDispatcherUnhandledException errors. The issue was accessing Robot properties (Account.Balance, Positions.Count, etc.) from background timer threads. Solution: wrapped all Robot property access in BeginInvokeOnMainThread() calls in CrashRecovery.cs and ErrorHandler.cs. This prevents the "Unable to invoke target method in current thread" error that was causing the bot to crash repeatedly.
- MANDATORY: All public methods and classes must use block comment documentation format (/*** ***/) with detailed Args, Returns, and Notes sections for comprehensive code documentation and maintainability.

## Scratchpad
Current Status: Core Infrastructure Phase Complete - Ready for Advanced Strategy Development

Major Achievements Completed:
✅ **CORE INFRASTRUCTURE PHASE COMPLETED** (Phase 1 - Foundation):

**✅ LOGGING & ERROR HANDLING SYSTEM:**
- [X] Comprehensive Logger.cs with 10MB file rotation and emergency fallbacks
- [X] Mandatory logging format: `ClassName | MethodName | message` implemented across all files
- [X] ErrorHandler.cs with centralized error management, categorization, and recovery
- [X] CrashRecovery.cs with automated health monitoring and system recovery
- [X] Thread-safe operations with BeginInvokeOnMainThread() for Robot properties
- [X] All files updated to use new logging format and block comment documentation

**✅ RISK MANAGEMENT SYSTEM:**
- [X] RiskManager.cs with comprehensive risk calculations and validation
- [X] Position sizing: Auto, Fixed Lots, Fixed Amount, Step-based modes
- [X] 9-point trade validation system (Symbol, Position, StopLoss, Spread, Hours, Direction, Risk, Account, Emergency)
- [X] ATR/ADR-based stop loss and take profit calculations
- [X] Support for multiple risk bases (Equity, Balance, FreeMargin, FixedBalance)

**✅ TRADE MANAGEMENT SYSTEM:**
- [X] TradeManager.cs with integrated trade execution
- [X] Full integration with RiskManager for comprehensive validation
- [X] Market order execution with comprehensive error handling
- [X] Position management and order validation

**✅ CORE BOT FRAMEWORK:**
- [X] CoreBot.cs main entry point with lifecycle management
- [X] 75+ configurable parameters across 7 logical groups
- [X] Constants.cs with system-wide configuration and enums
- [X] Modular architecture with separated concerns

**✅ BASIC STRATEGY IMPLEMENTATION:**
- [X] Simple trend following strategy with MA crossover logic
- [X] MovingAverage indicators (fast, slow, bias) with configurable periods
- [X] Buy/sell signal detection and execution
- [X] Full integration with risk management and error handling

**✅ DOCUMENTATION & STANDARDS:**
- [X] Comprehensive README.md with project lifecycle documentation
- [X] Block comment format (/*** ***/) implemented across all files
- [X] Mandatory logging guidelines and error handling standards
- [X] Git commit message conventions (feat, fix, docs, style, perf, test)

**Current Architecture:**
```
✅ CoreBot.cs (Main entry point with lifecycle management)
✅ utils/
   ├── Constants.cs (System configuration and enums)
   ├── Logger.cs (10MB rotating logs with emergency fallbacks)
   ├── ErrorHandler.cs (Centralized error management)
   └── CrashRecovery.cs (Health monitoring and recovery)
✅ trading/
   ├── RiskManager.cs (Position sizing and validation)
   └── TradeManager.cs (Trade execution and management)
✅ docs/
   └── README.md (Comprehensive project documentation)
```

**Next Development Phase:** Strategy Framework Enhancement
- [ ] Advanced strategy base classes and interfaces
- [ ] Multi-timeframe analysis capabilities
- [ ] Pattern recognition and signal generation
- [ ] Performance tracking and analytics
- [ ] Enhanced backtesting framework
- [ ] External integrations (notifications, data sources)

**Development Standards Established:**
- Comprehensive logging with mandatory format compliance
- Block comment documentation for all public methods
- Thread-safe operations with proper error handling
- Modular architecture with clear separation of concerns
- Git workflow with conventional commit messages

**System Status:** Production-ready core infrastructure with basic trading strategy operational. Ready for advanced strategy development and feature enhancement.

# cTrader cBot Implementation Todo List

## Initial Setup & Environment
- [X] Install Visual Studio 2022 with .NET desktop development workload
- [X] Install cTrader platform and create account
- [X] Verify API access is enabled in cTrader
- [X] Install cTrader Developer Tools
- [X] Create new cBot project in cTrader
- [X] Set up Git repository for version control
- [X] Configure build settings for different environments (dev, test, prod)
- [X] Create project structure according to architecture diagram

## Core Bot Module
- [X] Implement CoreBot.cs entry point class
- [X] Create lifecycle management (OnStart, OnTick, OnBar, OnStop)
- [X] Develop Constants.cs for system-wide configuration
- [X] Implement crash recovery mechanisms
- [ ] Create configuration management system
- [X] Develop comprehensive error handling framework
- [ ] Create core data models for market, trades and performance
- [ ] Implement all required interfaces (IStrategy, IIndicator, etc.)
- [X] Set up logging service for system-wide use
- [ ] Create utility classes and extension methods

## Market Module
- [ ] Implement DataManager.cs for market data acquisition
- [ ] Develop Symbols.cs for symbol management and filtering
- [ ] Create OhlcProcessor.cs for candle/bar data handling
- [ ] Implement TickProcessor.cs for tick-level data
- [ ] Develop MarketWatch.cs for multi-instrument monitoring
- [ ] Create PriceAnalysis.cs for price action analysis
- [ ] Implement market volatility metrics calculation
- [ ] Develop market condition identification system
- [ ] Create significant price level detection
- [ ] Implement correlation tracking between instruments

## Trading Module
- [ ] Develop OrderManager.cs for order creation and management
- [ ] Implement PositionManager.cs for position tracking
- [ ] Create TradeHistory.cs for historical trade analysis
- [X] Implement RiskManager.cs for position sizing
- [X] Develop ExecutionManager.cs for trade optimization
- [] Create order submission retry logic
- [X] Implement position modification capabilities
- [] Develop scaling in/out functionality
- [X] Create comprehensive risk limit enforcement system
- [] Implement trade recording with full context information
- [] Integrate ExecutionManager with TradeRecorder

## Strategy Module
- [X] Create StrategyManager.cs for coordination
- [X] Implement StrategyBase.cs abstract base class
- [X] Develop SignalGeneratorBase.cs for signal generation
- [X] Create EntryExitBase.cs for entry/exit logic
- [X] Implement StandardIndicators.cs wrappers
- [X] Develop IndicatorCombiner.cs for multi-indicator logic
- [X] Implement specific strategies:
  - [X] TrendFollowing.cs implementation
  - [X] MeanReversion.cs implementation
  - [X] Breakout.cs implementation
  - [ ] Scalping.cs implementation
- [ ] Create multi-timeframe signal confirmation
- [ ] Implement pattern recognition algorithms
- [X] Develop trailing stop exit strategies
- [ ] Implement partial position exit logic

## Analysis Module
- [ ] Create PerformanceTracker.cs for real-time monitoring
- [ ] Implement EquityCurve.cs calculation
- [ ] Develop TradeAnalytics.cs for statistics
- [ ] Create Drawdown.cs for drawdown analysis
- [ ] Implement ReportGenerator.cs for performance reporting
- [ ] Develop KPI calculation system
- [ ] Create trade pattern identification logic
- [ ] Implement expectancy and risk-adjusted return calculations
- [ ] Develop market condition performance analysis
- [ ] Create performance anomaly detection system

## Optimization Module
- [ ] Implement ParameterOptimizer.cs for strategy optimization
- [ ] Create WalkForwardTester.cs for walk-forward analysis
- [ ] Develop MonteCarloSimulator.cs for simulations
- [ ] Implement OptimizationMetrics.cs scoring functions
- [ ] Create multi-objective optimization algorithms
- [ ] Develop parameter stability analysis
- [ ] Implement confidence interval calculations
- [ ] Create visualization for parameter sensitivity
- [ ] Develop overfitting prevention mechanisms
- [ ] Implement optimization report generation

## UI Module
- [ ] Create custom UI controls:
  - [ ] DashboardControl.cs for main interface
  - [ ] StrategyControl.cs for strategy configuration
  - [ ] PerformanceControl.cs for visualization
- [ ] Implement visualization components:
  - [ ] ChartMarkers.cs for trade visualization
  - [ ] EquityChart.cs for equity curve display
  - [ ] IndicatorVisualizer.cs for indicator display
- [ ] Create dialog windows:
  - [ ] ConfigurationDialog.cs for settings
  - [ ] AlertDialog.cs for notifications
  - [ ] ReportDialog.cs for performance reports
- [ ] Implement customizable dashboard layouts
- [ ] Create visual parameter adjustment controls
- [ ] Develop chart annotation system
- [ ] Implement alert configuration and management
- [ ] Create configuration validation UI

## Data Module
- [ ] Implement DataStorage.cs for persistence management
- [ ] Create DatabaseManager.cs for database operations
- [ ] Develop FileStorage.cs for file-based storage
- [ ] Implement ExportManager.cs for data export
- [ ] Create efficient data compression for history
- [ ] Design and implement database schema
- [ ] Develop query optimization for performance
- [ ] Create backup and restore functionality
- [ ] Implement selective data export options
- [ ] Develop data synchronization between instances

## External Module
- [ ] Create notification services:
  - [ ] EmailService.cs for email alerts
  - [ ] TelegramService.cs for Telegram integration
  - [ ] PushNotification.cs for mobile alerts
- [ ] Implement third-party integrations:
  - [ ] ExternalApiClient.cs for API access
  - [ ] NewsProvider.cs for market news
  - [ ] EconomicCalendar.cs for economic data
- [ ] Develop import functionality:
  - [ ] StrategyImporter.cs for strategy import
  - [ ] HistoricalDataImporter.cs for data import
  - [ ] ConfigurationImporter.cs for settings import
- [ ] Create customizable notification templates
- [ ] Implement secure API key management
- [ ] Develop data validation for imports

## Testing
- [ ] Set up testing framework (NUnit/MSTest)
- [ ] Create unit tests for all core components
- [ ] Implement integration tests for module interactions
- [ ] Develop backtesting validation suite
- [ ] Create tests for error handling and recovery
- [ ] Implement performance benchmark tests
- [ ] Develop UI component tests
- [ ] Create test fixtures and mock data
- [ ] Implement continuous integration pipeline
- [ ] Document testing procedures and best practices

## Documentation
- [ ] Create user documentation:
  - [ ] Installation and setup guide
  - [ ] Configuration manual
  - [ ] Trading strategy descriptions
  - [ ] Troubleshooting guide
- [ ] Develop developer documentation:
  - [ ] Architecture overview
  - [ ] API reference
  - [ ] Extension points guide
  - [ ] Development environment setup
- [ ] Create operations documentation:
  - [ ] Deployment procedures
  - [ ] Backup and recovery guide
  - [ ] Performance tuning recommendations
  - [ ] Security considerations
- [ ] Implement XML code comments
- [ ] Create markdown files for GitHub repository
- [ ] Develop sample configuration guides

## Deployment & Release Preparation
- [ ] Create build automation scripts
- [ ] Implement semantic versioning system
- [ ] Create package deployment process
- [ ] Develop installation wizards or guides
- [ ] Create configuration migration tools
- [ ] Implement rollback procedures
- [ ] Develop release testing protocol
- [ ] Create changelog generation process
- [ ] Implement license management
- [ ] Prepare marketing materials and screenshots

## Compliance & Security
- [ ] Implement appropriate risk warnings
- [ ] Create comprehensive audit logging
- [ ] Develop secure credential storage
- [ ] Implement role-based access control
- [ ] Create data encryption for sensitive information
- [ ] Develop compliance reporting features
- [ ] Implement trade record archiving
- [ ] Create security review documentation
- [ ] Develop privacy policy and terms of use
- [ ] Implement broker-specific compliance features

## Performance Optimization
- [ ] Conduct performance profiling
- [ ] Optimize tick processing latency
- [ ] Improve memory usage patterns
- [ ] Optimize database access
- [ ] Improve UI responsiveness
- [ ] Reduce CPU usage during idle periods
- [ ] Optimize chart rendering
- [ ] Improve startup time
- [ ] Optimize backtest performance
- [ ] Create performance monitoring dashboards

## Maintenance & Roadmap Planning
- [ ] Plan version update schedule
- [ ] Create feature roadmap document
- [ ] Develop user feedback collection system
- [ ] Implement analytics for feature usage
- [ ] Create bug tracking and reporting process
- [ ] Develop backward compatibility policy
- [ ] Create deprecation policy for features
- [ ] Plan future API integration roadmap
- [ ] Document technical debt and refactoring needs
- [ ] Create long-term architecture evolution plan 